# ========== Introduction ==========
"""
Metaprogramming generates or mofdifies code. Python has facilities for dynamic metaprogramming,
like decorators and metaclasses. They make Python very flexible, but come with runtime overhead.
Compiled languages might have compile-time metaprogramming, like C preprocessor macros and C++ templates.
Those can be limiting or hard to use.

For the sake of AI, Mojo aims to provide powerful, and usable metaprogramming with zero runtime cost.
This compile-time metaprogramming uses the same language as runtime programs.

The main new Mojo feature is Parameters. Thinnk of them as a compile-time var that becomes a runtime constant.
Unlike in other languages, in Mojo, a parameter is considered as a compile-time value, and argument and expression refer
to runtime values.

In Mojo, you can add parameters to a struct or func, and you can define named parameter expressions (aliases)
that you can use as runtime constants.
"""

# ========== Parameterized Functions ==========
"""
To define a Parameterized func, add parameters in square brackets between then name and the arg list.
Parameters are formatted like and argument: Parameter name, followed by its type [Count: Int].
For example:
"""

fn repeat[count: Int](msg: String):
    @unroll
    for i in range(count):
        print(msg)

"""
@unroll unrolls loops at compile time. It only works if the loop limits are compile-time constants.
In main the Parameterized function is called.

The compiler resolves the Parameter values at compile-time, and creates a concrete version of it
for each unique parameter value. After resolving the Param values, and unrolling the loop, it basically is the following:

fn repeat_3(msg: String):
    print(msg)
    print(msg)
    print(msg)

NOTE:
Above isn't actually code generated by the compiler. After the Params are resolved, Mojo code has already
been transformed to an intermediate MLIR representation.

If the compiler cnnot resolve all Parameters, it fails.
"""

fn main():
    repeat[3]("Hello")