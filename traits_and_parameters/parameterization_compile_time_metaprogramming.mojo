# ========== Introduction ==========
"""
Metaprogramming generates or mofdifies code. Python has facilities for dynamic metaprogramming,
like decorators and metaclasses. They make Python very flexible, but come with runtime overhead.
Compiled languages might have compile-time metaprogramming, like C preprocessor macros and C++ templates.
Those can be limiting or hard to use.

For the sake of AI, Mojo aims to provide powerful, and usable metaprogramming with zero runtime cost.
This compile-time metaprogramming uses the same language as runtime programs.

The main new Mojo feature is Parameters. Thinnk of them as a compile-time var that becomes a runtime constant.
Unlike in other languages, in Mojo, a parameter is considered as a compile-time value, and argument and expression refer
to runtime values.

In Mojo, you can add parameters to a struct or func, and you can define named parameter expressions (aliases)
that you can use as runtime constants.
"""

# ========== Parameterized Functions ==========
"""
To define a Parameterized func, add parameters in square brackets between then name and the arg list.
Parameters are formatted like and argument: Parameter name, followed by its type [Count: Int].
For example:
"""

fn repeat[count: Int](msg: String):
    @unroll
    for i in range(count):
        print(msg)

"""
@unroll unrolls loops at compile time. It only works if the loop limits are compile-time constants.
In main the Parameterized function is called.

The compiler resolves the Parameter values at compile-time, and creates a concrete version of it
for each unique parameter value. After resolving the Param values, and unrolling the loop, it basically is the following:

fn repeat_3(msg: String):
    print(msg)
    print(msg)
    print(msg)

NOTE:
Above isn't actually code generated by the compiler. After the Params are resolved, Mojo code has already
been transformed to an intermediate MLIR representation.

If the compiler cnnot resolve all Parameters, it fails.
"""

# ========== Parameterized Structs ==========
"""
You can use parameterized structs to build generic containers. 
Below an example of a generic Array type:
"""

struct GenericArray[T: AnyRegType]:
    var data: Pointer[T]
    var size: Int

    fn __init__(inout self, *elements: T):
        self.size = len(elements)
        self.data = Pointer[T].alloc(self.size)

        for i in range(self.size):
            self.data[i] = elements[i]

    fn __del__(owned self):
        self.data.free()

    fn __getitem__(self, i: Int) raises -> T:
        if (i < self.size):
            return self.data[i]
        else:
            raise Error("Out of bounds")

"""
The T is a placeholder for the datatype to store in the Array (a Type parameter). T is typed as AnyRegType.
This is a meta type representing any register-passable type, meaning the Array can hold fixed-size datatypes (e.g. Ints, Flaots)
that can be passed in a machine register. It does not represent dynamically allocated data (Strings, vectors, etc.)

NOTE:
"T" can be anyu name or symbol, it's used as a convention

As with Parameterized funcs,  you need to pass Parameter values when using a Parameterized struct. In the case of the example,
when instantiating the Array, you need to specify the type to store.
T is used throughout the struct where you'd usually see a single type name (e.g. return type of __getitem__).

Besides an AnyRegType, there's a more generic AnyType, which includes all Mojo types.

A parametereized struct can use the Self type to represent a concrete instance of the struct (all Params specified).
You could add a static factory method to create concrete types structs.

@staticmethod
fn splat(count: Int, value: T) -> Self
    # create new array with {count} instances of the given value

GenericArray[Float64].splat(8, 0)
"""

fn main():
    repeat[3]("Hello")

    # Parameterized Structs
    var gen_arr = GenericArray[Int](1, 2, 3, 4)
    try:
        for i in range(gen_arr.size):
            print(gen_arr[i], sep=" ", end="")
    except:
        print("Errrrrrr")